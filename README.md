# Git & GitHub Tutorial

## Inhaltsverzeichnis - test 2

- [Git \& GitHub Tutorial](#git--github-tutorial)
  - [Inhaltsverzeichnis - test 2](#inhaltsverzeichnis---test-2)
    - [**Chaos im Projekt? Git \& GitHub sind die L√∂sung!**](#chaos-im-projekt-git--github-sind-die-l√∂sung)
    - [**Was ist Git?**](#was-ist-git)
    - [**Was ist GitHub?**](#was-ist-github)
    - [**Warum sollte man Git \& GitHub nutzen?**](#warum-sollte-man-git--github-nutzen)
    - [**Vorteile von GitHub:**](#vorteile-von-github)
    - [**Warum ist Git heute so wichtig?**](#warum-ist-git-heute-so-wichtig)
    - [**Wie funktioniert Git?**](#wie-funktioniert-git)
    - [**Erster Commit mit Git**](#erster-commit-mit-git)
    - [**√Ñnderungen verwalten mit Git**](#√§nderungen-verwalten-mit-git)
    - [**GitHub-Konto erstellen \& Repository ver√∂ffentlichen**](#github-konto-erstellen--repository-ver√∂ffentlichen)
    - [**Zusammenarbeit im Team mit Git \& GitHub**](#zusammenarbeit-im-team-mit-git--github)
    - [**Warum Branches verwenden?**](#warum-branches-verwenden)
    - [**Branches in der Praxis verwenden**](#branches-in-der-praxis-verwenden)
    - [**Merge \& Zusammenarbeit**](#merge--zusammenarbeit)
    - [**Commits bearbeiten, zur√ºcknehmen \& wiederherstellen**](#commits-bearbeiten-zur√ºcknehmen--wiederherstellen)
    - [**Commits l√∂schen oder r√ºckg√§ngig machen**](#commits-l√∂schen-oder-r√ºckg√§ngig-machen)
    - [**Sicherer Weg: `git revert` verwenden**](#sicherer-weg-git-revert-verwenden)
    - [**Gel√∂schte Commits wiederherstellen**](#gel√∂schte-commits-wiederherstellen)
    - [**Was ist ein Fork?**](#was-ist-ein-fork)
    - [**Feature entwickeln \& Commiten**](#feature-entwickeln--commiten)
    - [**Was ist ein Pull Request (PR)?**](#was-ist-ein-pull-request-pr)
    - [**Review \& Merge-Prozess**](#review--merge-prozess)
    - [**Warum ist das wichtig?**](#warum-ist-das-wichtig)
    - [**Was ist ein GitHub Issue?**](#was-ist-ein-github-issue)
    - [**Gutes Issue erstellen**](#gutes-issue-erstellen)
    - [**Issue l√∂sen ‚Äì Schritt f√ºr Schritt**](#issue-l√∂sen--schritt-f√ºr-schritt)
    - [**Pull Request (PR) erstellen**](#pull-request-pr-erstellen)
    - [**Merge-Strategien im √úberblick**](#merge-strategien-im-√ºberblick)
    - [**Vollst√§ndiger Workflow mit CLI oder Web**](#vollst√§ndiger-workflow-mit-cli-oder-web)
    - [**Was ist ein Merge?**](#was-ist-ein-merge)
    - [**Merge mit --no-ff Option**](#merge-mit---no-ff-option)
    - [**Was ist Rebase?**](#was-ist-rebase)
    - [**Unterschied: Merge vs. Rebase**](#unterschied-merge-vs-rebase)
    - [**Wann Rebase, wann Merge?**](#wann-rebase-wann-merge)
    - [**Best Practices im Team**](#best-practices-im-team)
    - [**Was ist `git stash`?**](#was-ist-git-stash)
    - [**Typisches Szenario**](#typisches-szenario)
    - [**Wichtige `stash`-Befehle**](#wichtige-stash-befehle)
    - [**Was passiert bei einem Merge-Konflikt nach `stash`?**](#was-passiert-bei-einem-merge-konflikt-nach-stash)
    - [**Grenzen von `stash`**](#grenzen-von-stash)
    - [**Was ist `git worktree`?**](#was-ist-git-worktree)
    - [**Warum `worktree` statt `stash`?**](#warum-worktree-statt-stash)
    - [**Beispiel: Zwei neue Features**](#beispiel-zwei-neue-features)
    - [**Entwicklung \& Zusammenf√ºhren**](#entwicklung--zusammenf√ºhren)
- [(dein Code)](#dein-code)
  - [**Merge oder Rebase?**](#merge-oder-rebase)
    - [**Problem: Gro√üe Dateien in GitHub**](#problem-gro√üe-dateien-in-github)
    - [**L√∂sung: Git LFS (Large File Storage)**](#l√∂sung-git-lfs-large-file-storage)
    - [**Git LFS einrichten \& verwenden**](#git-lfs-einrichten--verwenden)
    - [**Projekt klonen mit LFS-Dateien**](#projekt-klonen-mit-lfs-dateien)
    - [**Vorteile von Git LFS**](#vorteile-von-git-lfs)
    - [**Was kommt als N√§chstes?**](#was-kommt-als-n√§chstes)
    - [**Problem: Sensible Daten \& gro√üe Dateien in der Git-Historie**](#problem-sensible-daten--gro√üe-dateien-in-der-git-historie)
    - [**L√∂sung: `git filter-repo`**](#l√∂sung-git-filter-repo)
    - [**Gro√üe Dateien aus Git entfernen**](#gro√üe-dateien-aus-git-entfernen)
    - [**API-Schl√ºssel ersetzen**](#api-schl√ºssel-ersetzen)
    - [**Wichtige Hinweise**](#wichtige-hinweise)
    - [**Fazit**](#fazit)
    - [**Was ist ein Git Submodul?**](#was-ist-ein-git-submodul)
    - [**Warum Submodule verwenden?**](#warum-submodule-verwenden)
    - [**Beispiel: Mathematischer Parser als Submodul**](#beispiel-mathematischer-parser-als-submodul)
    - [**Submodul updaten \& verwalten**](#submodul-updaten--verwalten)
    - [**Submodul wieder entfernen**](#submodul-wieder-entfernen)
    - [**Was ist ein Git Subtree?**](#was-ist-ein-git-subtree)
    - [**Submodule vs. Subtree**](#submodule-vs-subtree)
    - [**Subtree hinzuf√ºgen ‚Äì Beispiel**](#subtree-hinzuf√ºgen--beispiel)
    - [**Subtree verwenden \& verwalten**](#subtree-verwenden--verwalten)
    - [**Vorteile von Git Subtree**](#vorteile-von-git-subtree)
    - [**Was ist `git bundle`?**](#was-ist-git-bundle)
    - [**Warum `git bundle` nutzen?**](#warum-git-bundle-nutzen)
    - [**Repo als Bundle speichern**](#repo-als-bundle-speichern)
    - [**Einsatzm√∂glichkeiten von `git bundle`**](#einsatzm√∂glichkeiten-von-git-bundle)
    - [**Was ist ein Git Patch?**](#was-ist-ein-git-patch)
    - [**Patch-Datei erstellen**](#patch-datei-erstellen)
    - [**Patch anwenden**](#patch-anwenden)
    - [**Wann Git Patch verwenden?**](#wann-git-patch-verwenden)
    - [**Was ist GitHub Actions?**](#was-ist-github-actions)
    - [**Warum GitHub Actions verwenden?**](#warum-github-actions-verwenden)
    - [**Beispiel: Super-Linter einrichten**](#beispiel-super-linter-einrichten)
    - [**Was macht der Linter?**](#was-macht-der-linter)
    - [**Fehler erkennen \& beheben**](#fehler-erkennen--beheben)
    - [**Was sind Git Hooks?**](#was-sind-git-hooks)
    - [**Warum Git Hooks verwenden?**](#warum-git-hooks-verwenden)
    - [**Beispiele f√ºr wichtige Hooks**](#beispiele-f√ºr-wichtige-hooks)
    - [**Commit-Message-Format pr√ºfen**](#commit-message-format-pr√ºfen)
    - [**Automatisierung im Team**](#automatisierung-im-team)
    - [**Was ist die GitHub API?**](#was-ist-die-github-api)
    - [**Voraussetzung: Token erstellen**](#voraussetzung-token-erstellen)
    - [**API-Befehle ausf√ºhren (z.‚ÄØB. mit `curl`)**](#api-befehle-ausf√ºhren-zb-mit-curl)
    - [**Was ist mit der API m√∂glich?**](#was-ist-mit-der-api-m√∂glich)
    - [**Was ist Git eigentlich?**](#was-ist-git-eigentlich)
    - [**GitHub**](#github)
    - [**GitLab**](#gitlab)
    - [**Bitbucket**](#bitbucket)
    - [**Azure DevOps**](#azure-devops)
    - [**AWS CodeCommit**](#aws-codecommit)
    - [**Vergleich ‚Äì Wann was nutzen?**](#vergleich--wann-was-nutzen)
    - [**Git Workflows ‚Äì √úbersicht**](#git-workflows--√ºbersicht)
    - [**1. GitHub Flow**](#1-github-flow)
    - [**2. Git Flow**](#2-git-flow)
    - [**3. Fork Workflow**](#3-fork-workflow)
    - [**4. Trunk Based Development**](#4-trunk-based-development)
    - [**5. GitLab Flow**](#5-gitlab-flow)
    - [**6. Release Flow (Microsoft Style)**](#6-release-flow-microsoft-style)
    - [**Vergleich \& Empfehlung**](#vergleich--empfehlung)
    - [**GitHub Projects ‚Äì Planung \& Nachverfolgung**](#github-projects--planung--nachverfolgung)
    - [**1. Projekt anlegen**](#1-projekt-anlegen)
    - [**2. Aufgaben verwalten**](#2-aufgaben-verwalten)
    - [**3. Tabellenansicht**](#3-tabellenansicht)
    - [**4 Kanban Board**](#4-kanban-board)
    - [**5. Vorteile**](#5-vorteile)
    - [**Gelernte Inhalte festigen ‚Äì Git \& GitHub effektiv anwenden**](#gelernte-inhalte-festigen--git--github-effektiv-anwenden)
    - [**Wie bleibt das alles im Kopf?**](#wie-bleibt-das-alles-im-kopf)
    - [**Simuliere echte Beitr√§ge**](#simuliere-echte-beitr√§ge)
    - [**Wiederholung macht Meister**](#wiederholung-macht-meister)
    - [**Zusammenf√ºhrung**](#zusammenf√ºhrung)

### **Chaos im Projekt? Git & GitHub sind die L√∂sung!**

üîß In einem Teamprojekt kann es schnell un√ºbersichtlich werden:  
‚Äì Wer hat was ge√§ndert?  
‚Äì Eine Datei wurde versehentlich gel√∂scht ‚Äì und jetzt?  
‚Äì Zwei Personen arbeiten an derselben Datei ‚Äì wessen Code z√§hlt?

üí° Genau hier setzt diese Schulung an:  
Du lernst Git & GitHub **von Grund auf bis zum Expertenniveau** ‚Äì praxisnah und verst√§ndlich.

üìö **Was du lernen wirst:**  
‚Äì √Ñnderungen verfolgen & r√ºckg√§ngig machen  
‚Äì Code-Konflikte vermeiden und l√∂sen  
‚Äì Im Team organisiert und stressfrei arbeiten  
‚Äì Projekte versionieren, sichern und ver√∂ffentlichen  
‚Äì Automatisierung und Zusammenarbeit effizient gestalten

‚úÖ Am Ende kannst du ein komplettes Projekt professionell mit Git verwalten ‚Äì sicher, strukturiert und teamf√§hig.

### **Was ist Git?**

Git ist ein Versionskontrollsystem, mit dem du verschiedene Versionen deiner Dateien lokal speichern und verwalten kannst. Du kannst jederzeit zu einer √§lteren Version zur√ºckkehren.

### **Was ist GitHub?**

GitHub ist eine Online-Plattform, auf der du deine mit Git verwalteten Projekte speichern, teilen und gemeinsam mit anderen bearbeiten kannst.

### **Warum sollte man Git & GitHub nutzen?**  

Ohne Git ist die Arbeit fehleranf√§llig:  
‚Äì √Ñnderungen gehen verloren  
‚Äì Fehler lassen sich schwer r√ºckg√§ngig machen  
‚Äì Teamarbeit wird chaotisch

Mit Git & GitHub kannst du:  
‚Äì Fehler leicht korrigieren  
‚Äì √Ñnderungen nachvollziehen  
‚Äì Konfliktfrei im Team arbeiten

### **Vorteile von GitHub:**  

‚Äì Weltweit gr√∂√üte Open-Source-Plattform  
‚Äì Projekte ver√∂ffentlichen & Beitr√§ge zu anderen leisten  
‚Äì Eigene Arbeit sichtbar machen (auch f√ºr Arbeitgeber)

### **Warum ist Git heute so wichtig?**  

Git-Kenntnisse sind in der Softwarebranche Standard. Viele Unternehmen nutzen es ‚Äì also ist es ein gro√üer Pluspunkt in deiner Entwicklerlaufbahn!

### **Wie funktioniert Git?**

üîπ Git speichert **Dateiversionen** nicht direkt, sondern in mehreren Schritten:

1. **Working Directory (Arbeitsverzeichnis):**  
   Hier erstellst, √§nderst oder l√∂schst du Dateien. Git verfolgt sie noch nicht automatisch.

2. **Staging Area (Zwischenspeicher):**  
   Nur **fertige und speicherbereite √Ñnderungen** werden hier hinzugef√ºgt.  
   ‚Üí So beh√§ltst du die Kontrolle und vermeidest Chaos.

3. **Repository (Lokales Git-Depot):**  
   Von der Staging Area werden die √Ñnderungen ins Repository √ºbernommen (= Commit).  
   Git erstellt dabei mit einem **SHA-1-Hash** einen eindeutigen Fingerabdruck f√ºr jede Version.

üîÅ **Zur√ºckspringen im Verlauf:**  
Alle Versionen sind wie eine Kette miteinander verbunden. Du kannst jederzeit zu einem fr√ºheren Stand zur√ºckkehren.

üåç **Zusammenarbeit mit GitHub:**  
Durch das Hochladen ins **Remote-Repository (z.‚ÄØB. GitHub)** k√∂nnen Teammitglieder die neuesten √Ñnderungen abrufen, weiterentwickeln und gemeinsam am Projekt arbeiten.

### **Erster Commit mit Git**

üîß **Git installieren & starten:**  
‚Äì Git von der offiziellen Website herunterladen  
‚Äì Git Bash (Terminal) √∂ffnen ‚Äì ideal f√ºr Git-Kommandos unter Windows

üìÅ **Projektordner initialisieren:**  
‚Äì Mit `cd` ins Arbeitsverzeichnis wechseln  
‚Äì `git init` ausf√ºhren ‚Üí Git erstellt einen `.git`-Ordner zur Versionskontrolle

üìÑ **Dateien verfolgen:**  
‚Äì `git status` zeigt: nicht verfolgte Dateien = **rot**  
‚Äì `git add dateiname` ‚Üí Datei wird zur Staging Area hinzugef√ºgt = **gr√ºn**  
‚Äì `git add .` ‚Üí alle √Ñnderungen auf einmal hinzuf√ºgen

üë§ **Nutzerinformationen konfigurieren:**  
‚Äì `git config --global user.name "Dein Name"`  
‚Äì `git config --global user.email "deine@email.com"`  
‚Üí Git wei√ü, wer √Ñnderungen gemacht hat (wichtig f√ºr Commits und Zusammenarbeit)

üíæ **Commit durchf√ºhren:**  
‚Äì `git commit -m "Nachricht"` ‚Üí √Ñnderungen dauerhaft speichern  
‚Äì Jeder Commit bekommt eine eindeutige ID (SHA-1)

üïò **Verlauf anzeigen:**  
‚Äì `git log` zeigt Commit-Historie mit ID, Nachricht und Zeit

### **√Ñnderungen verwalten mit Git**

üîç **Was hat sich ge√§ndert?**  
‚Äì `git diff` zeigt ge√§nderte Zeilen:  
‚ÄÉüü© gr√ºn = hinzugef√ºgt‚ÄÉüü• rot = gel√∂scht  
‚Äì `git diff datei.txt` ‚Üí nur bestimmte Datei pr√ºfen

üì• **√Ñnderungen zur Staging Area hinzuf√ºgen:**  
‚Äì `git add .` ‚Üí alle √Ñnderungen  
‚Äì Danach zeigt `git diff` keine √Ñnderungen mehr, da sie jetzt im Zwischenspeicher sind  
‚Äì Mit `git diff --staged` sieht man die Inhalte in der Staging Area

‚Ü©Ô∏è **√Ñnderungen zur√ºcknehmen:**  
‚Äì Arbeitsverzeichnis zur√ºcksetzen (eine Datei):  
‚ÄÉ`git restore datei.txt`  
‚Äì Alle √Ñnderungen im Arbeitsverzeichnis zur√ºcknehmen:  
‚ÄÉ`git restore .`

üì§ **Staging Area zur√ºcksetzen:**  
‚Äì Einzelne Datei entfernen:  
‚ÄÉ`git reset datei.txt`  
‚Äì Alle Dateien entfernen:  
‚ÄÉ`git reset`  
üìù Achtung: √Ñnderungen im Arbeitsverzeichnis bleiben erhalten!

üìå Wenn √Ñnderungen **ganz gel√∂scht** werden sollen:  
‚Üí Danach erneut `git restore` verwenden

### **GitHub-Konto erstellen & Repository ver√∂ffentlichen**

üë§ **GitHub-Konto anlegen:**  
‚Äì Verwende dieselbe E-Mail wie bei `git config`  
‚Äì Benutzername & Passwort w√§hlen  
‚Äì Verifizierung abschlie√üen ‚Üí Konto ist bereit

‚öôÔ∏è **Nutzerinformationen verwalten:**  
‚Äì √Ñndern: `git config --global user.name "Neuer Name"`  
‚Äì L√∂schen: `git config --unset --global user.email`

üìÅ **Lokales Repository vorbereiten:**  
‚Äì In Projektordner wechseln  
‚Äì `git init` ‚Üí Git-Repository starten  
‚Äì `git add .` ‚Üí alle Dateien zur Staging Area hinzuf√ºgen  
‚Äì `git commit -m "Erster Commit"` ‚Üí √Ñnderungen speichern

‚òÅÔ∏è **GitHub-Repository erstellen & verkn√ºpfen:**  
‚Äì Auf GitHub neues Repository anlegen  
‚Äì Link kopieren und verkn√ºpfen:  
  `git remote add origin [Repo-Link]`  
‚Äì Verbindung aufbauen & pushen:  
  `git push -u origin master`  
‚Üí `-u` merkt sich die Verbindung f√ºr zuk√ºnftige Pushes

üîê **Authentifizierung:**  
‚Äì Einloggen per Browser, Token oder Code  
‚Üí Danach ist das lokale Projekt auf GitHub verf√ºgbar!

### **Zusammenarbeit im Team mit Git & GitHub**

üë• **Teammitglied zum Projekt hinzuf√ºgen:**  
‚Äì Auf GitHub unter *Settings > Collaborators*  
‚Äì Benutzername eingeben ‚Üí Einladung senden  
‚Äì Nach Annahme kann die Person am Projekt mitarbeiten

üíª **Projekt auf den eigenen Rechner klonen:**  
‚Äì Terminal √∂ffnen ‚Üí `git clone [Repo-Link]`  
‚Äì Projekt lokal verf√ºgbar ‚Üí bereit zur Entwicklung

üì§ **Eigene √Ñnderungen hochladen:**  
‚Äì Datei erstellen oder bearbeiten  
‚Äì `git add`, `git commit -m "Nachricht"`, `git push`  
‚Üí √Ñnderungen gehen ins Remote-Repo (GitHub)

üì• **√Ñnderungen vom Team abrufen:**  
‚Äì `git fetch` ‚Üí l√§dt Updates, aber noch nicht sichtbar  
‚Äì `git merge` ‚Üí integriert √Ñnderungen in das Arbeitsverzeichnis  
‚Äì Alternativ: `git pull` ‚Üí beides in einem Schritt

‚ö†Ô∏è **Push-Fehler?**  
‚Äì Wenn Remote-Repo neuer ist als lokales:  
‚Üí `git pull` vorher n√∂tig  
‚Üí Konfliktl√∂sung ggf. mit Merge-Commit (Editor mit `:q` schlie√üen)

üìö **Verlauf & Kontrolle:**  
‚Äì `git log` zeigt alle Commits  
‚Üí √Ñnderungen sind nachvollziehbar & sauber dokumentiert

### **Warum Branches verwenden?**

üå± **Stabile Hauptversion sch√ºtzen:**  
‚Äì Haupt-Branch (z.‚ÄØB. `main` oder `master`) sollte **immer stabil** und funktionsf√§hig sein.  
‚Äì Neue Features & Bugfixes werden in **eigenen Branches** entwickelt.

‚öôÔ∏è **Vorteile von Branches:**  
‚Äì √Ñnderungen riskieren nicht den Hauptcode  
‚Äì Parallele Entwicklung mehrerer Funktionen m√∂glich  
‚Äì Fehlerhafte Branches k√∂nnen **einfach gel√∂scht** werden

---

### **Branches in der Praxis verwenden**

üîç **Branch anzeigen & wechseln:**  
‚Äì `git branch` ‚Üí aktuelle Branch anzeigen  
‚Äì `git switch branchname` ‚Üí zu bestehendem Branch wechseln  
‚Äì `git switch -c neuerBranch` ‚Üí neuen Branch erstellen und wechseln

üß™ **Beispiel:**  
‚Äì Branch: `feature/login-system`  
‚Äì √Ñnderungen vornehmen, committen und pushen:  
  `git push -u origin feature/login-system`

---

### **Merge & Zusammenarbeit**

üîÑ **Branch in Hauptcode integrieren:**  
‚Äì Zu `main` wechseln: `git switch main`  
‚Äì Updates abrufen: `git pull origin main`  
‚Äì Zusammenf√ºhren: `git merge feature/login-system`  
‚Äì √Ñnderungen hochladen: `git push`

‚ö†Ô∏è **Merge-Konflikte vermeiden:**  
‚Äì Vor dem Merge: immer **aktuelle Hauptversion** holen  
‚Äì Sonst: Git erlaubt keinen Merge ‚Üí Konfliktgefahr

### **Commits bearbeiten, zur√ºcknehmen & wiederherstellen**

üìù **Commit-Nachricht √§ndern:**  
‚Äì `git commit --amend` ‚Üí letzte Nachricht im Editor bearbeiten

‚è™ **Zu fr√ºherem Commit wechseln:**  
‚Äì `git checkout [Commit-ID]`  
‚Äì Zur√ºck zum Hauptbranch: `git checkout main`

### **Commits l√∂schen oder r√ºckg√§ngig machen**

üß© **Soft Reset:**  
‚Äì `git reset --soft HEAD~1`  
‚Üí Letzter Commit wird entfernt, √Ñnderungen bleiben in der Staging Area

üß© **Mixed Reset:**  
‚Äì `git reset --mixed HEAD~1`  
‚Üí Commit wird gel√∂scht, √Ñnderungen im Arbeitsverzeichnis bleiben

üß® **Hard Reset:**  
‚Äì `git reset --hard HEAD~1`  
‚Üí Commit + √Ñnderungen **komplett gel√∂scht**  
‚Äì GitHub aktualisieren: `git push --force`  
‚ö†Ô∏è Gefahr: Datenverlust!

### **Sicherer Weg: `git revert` verwenden**

‚Äì `git revert [Commit-ID]`  
‚Üí Erstellt neuen Commit, der den alten r√ºckg√§ngig macht  
‚úÖ Ideal f√ºr Teamarbeit, keine Daten gehen verloren

### **Gel√∂schte Commits wiederherstellen**

üîÅ **`git reflog` ‚Äì die geheime Zeitmaschine:**  
‚Äì Zeigt alle fr√ºheren Referenzen, inkl. gel√∂schter Commits  
‚Äì Wiederherstellen mit: `git reset --hard [Commit-ID]`  
‚ö†Ô∏è Achtung: Reflog wird **nach 90 Tagen** automatisch gel√∂scht

### **Was ist ein Fork?**

üîÑ **Fork = Projektkopie in dein eigenes GitHub-Konto**  
‚Äì Erm√∂glicht dir, fremde Repos zu bearbeiten  
‚Äì CLI-Befehl: `gh repo fork`  
‚Äì Danach: `cd projektname` ‚Üí Projekt lokal bearbeiten

### **Feature entwickeln & Commiten**

üí° Beispiel: Bug im Taschenrechner-Projekt  
‚Äì Neues Feature/Fehlerbehebung ‚Üí **neuen Branch** erstellen  
‚Äì √Ñnderungen vornehmen  
‚Äì Commit mit `git commit -m "Fehlerbehebung"`  
‚Äì Push mit `git push` (auf deinen Fork)

### **Was ist ein Pull Request (PR)?**

üì¨ **PR = Anfrage zur √úbernahme deiner √Ñnderungen ins Original-Repo**  
‚Äì CLI-Befehl: `gh pr create`  
‚Üí Titel & Beschreibung angeben

üëÄ Projektbesitzer sieht den PR mit `gh pr list`  
‚Üí Details pr√ºfen mit `gh pr view`  
‚Üí √Ñnderungen vergleichen: `gh pr diff`

### **Review & Merge-Prozess**

‚úÖ **PR-Ablauf im Original-Repo:**  
‚Äì Kommentar hinzuf√ºgen: `gh pr review --comment`  
‚Äì Genehmigen: `gh pr review --approve`  
‚Äì √Ñnderungen anfordern: `gh pr review --request-changes`  
‚Äì Merge durchf√ºhren: `gh pr merge`  
‚Üí PR wird automatisch geschlossen

### **Warum ist das wichtig?**

üåç **Open-Source-Leben = Zusammenarbeit**  
‚Äì Mit Fork & PR kannst du zur Entwicklung beitragen  
‚Äì Auch ohne Code: durch Issues, Feature-Vorschl√§ge, Doku-Verbesserungen  
‚Äì CLI macht den Prozess **schnell & effizient**

### **Was ist ein GitHub Issue?**

üõ†Ô∏è Issues dienen zur Fehlererfassung, Feature-Vorschl√§gen oder Organisation.  
‚Äì Fehler = Bug melden  
‚Äì Neue Idee = Feature vorschlagen  
‚Äì Nutzung √ºber Web oder CLI:  
‚ÄÉ`gh issue create`

### **Gutes Issue erstellen**

‚úçÔ∏è Im Issue-Titel und Beschreibung:  
‚Äì Was ist das Problem?  
‚Äì Wie wurde es entdeckt?  
‚Äì Wie k√∂nnte man es l√∂sen?

‚úÖ Nachverfolgbarkeit durch:  
‚Äì Labels wie `bug`, `enhancement`  
‚Äì Selbst zuweisen: `gh issue edit --assign @me`

### **Issue l√∂sen ‚Äì Schritt f√ºr Schritt**

1. Neuen Branch erstellen: `gh repo clone`, `gh pr checkout -c fix/issue-123`  
2. Fehler beheben oder Feature umsetzen  
3. Commit mit Referenz:  
‚ÄÉ`git commit -m "Fix: #123 Eingabevalidierung hinzugef√ºgt"`  
‚Üí GitHub schlie√üt Issue automatisch beim Merge

### **Pull Request (PR) erstellen**

üì¨ Nach dem Commit:  
‚Äì `gh pr create` ‚Üí Titel + Beschreibung  
‚Äì √Ñnderung pr√ºfen: `gh pr diff`  
‚Äì PR verlinkt automatisch das Issue  
‚Üí Nach Merge wird Issue geschlossen

### **Merge-Strategien im √úberblick**

üîÄ Drei Wege zum Merge:  
‚Äì **Merge Commit**: mehrere Commits, Verlauf bleibt erhalten  
‚Äì **Rebase**: √Ñnderungen oben auf aktuellen Stand setzen  
‚Äì **Squash**: alle Commits zu einem einzigen zusammenfassen

üßπ Nicht mehr genutzte Branches mit:  
`gh pr delete` oder `git branch -d`

### **Vollst√§ndiger Workflow mit CLI oder Web**

‚úÖ Projekt verbessern durch:  
‚Äì Fehler melden  
‚Äì √Ñnderungen vorschlagen & umsetzen  
‚Äì Pull Request √∂ffnen  
‚Äì Merge & automatische Issue-Schlie√üung

üí° Sowohl mit CLI als auch GitHub-Weboberfl√§che m√∂glich

### **Was ist ein Merge?**

üîÄ Merge = √Ñnderungen aus einem Branch in den Hauptbranch √ºbernehmen  
‚Äì Standardkommando: `git merge branchname`  
‚Äì Wenn Hauptbranch **aktuell** ist ‚Üí **Fast-Forward Merge** (kein extra Commit)  
‚Äì Wenn √Ñnderungen im Hauptbranch vorhanden ‚Üí **Merge-Commit** wird erstellt

### **Merge mit --no-ff Option**

üìå `git merge --no-ff`  
‚Äì Erzwingt immer einen Merge-Commit  
‚Äì Vorteil: Historie bleibt **sichtbar & nachvollziehbar**

### **Was ist Rebase?**

üìö Rebase = √Ñnderungen ‚Äûoben draufsetzen‚Äú, als ob sie zuletzt gemacht wurden  
‚Äì Kommando: `git rebase main`  
‚Äì Die Commits deines Branches werden **neu geschrieben**  
‚Üí Saubere, lineare Commit-Historie

### **Unterschied: Merge vs. Rebase**

| Merge                              | Rebase                               |
|------------------------------------|---------------------------------------|
| Beibehaltung der Verzweigungen     | Lineare Historie                     |
| Echte Merge-Commits                | Commit-Historie wird neu geschrieben |
| Gut f√ºr Teams                      | Gut f√ºr Einzelentwicklung            |
| Keine Gefahr f√ºr fremde Historie   | Vorsicht: **Force Push n√∂tig!**      |

### **Wann Rebase, wann Merge?**

‚úÖ **Rebase sinnvoll bei:**  
‚Äì Lokaler Entwicklung  
‚Äì Eigenen Branch aktuell halten  
‚Äì Vor dem finalen Merge zur Vereinfachung der Historie  

üö´ **Rebase vermeiden bei:**  
‚Äì Gemeinsamen Branches im Team  
‚Äì Wenn andere schon basierend auf dem Branch arbeiten  

### **Best Practices im Team**

‚ö†Ô∏è Vorsicht bei `git push --force` nach einem Rebase  
‚Äì Nur einsetzen, wenn du **allein auf dem Branch** arbeitest  
‚Äì In Teamprojekten ‚Üí lieber `merge` oder `merge --no-ff` verwenden

### **Was ist `git stash`?**

üì¶ `git stash` erm√∂glicht es dir, **zwischenzuspeichern**, woran du arbeitest ‚Äì ohne zu committen.  
‚Üí Ideal, wenn du spontan zu einem anderen Branch wechseln musst.

### **Typisches Szenario**

1. Neue Funktion (z.‚ÄØB. Logarithmus) begonnen  
2. Muss pausiert werden ‚Üí `git stash`  
3. Andere Funktion (z.‚ÄØB. Modulo) entwickeln  
4. Danach urspr√ºngliche √Ñnderungen mit `git stash pop` zur√ºckholen

### **Wichtige `stash`-Befehle**

üõ†Ô∏è  
‚Äì √Ñnderungen speichern: `git stash`  
‚Äì Zur√ºckholen & entfernen: `git stash pop`  
‚Äì Zur√ºckholen & **behalten**: `git stash apply`  
‚Äì Alle Stashes zeigen: `git stash list`  
‚Äì Einzelnen entfernen: `git stash drop`  
‚Äì Alle l√∂schen: `git stash clear`  
‚Äì Mit Beschreibung: `git stash save "Nachricht"` (√§lterer Syntax)

### **Was passiert bei einem Merge-Konflikt nach `stash`?**

‚ö†Ô∏è Wenn zwei Branches dieselbe Datei ver√§ndern:  
‚Äì `git` zeigt dir die Konflikte im Code  
‚Äì Du entscheidest, was √ºbernommen werden soll  
‚Äì Danach: Konflikte aufl√∂sen und committen

### **Grenzen von `stash`**

üìâ Wenn du **h√§ufig stashst**, kann es schnell un√ºbersichtlich werden  
‚Üí Nicht ideal f√ºr **langfristige, parallele Entwicklungen**

‚úÖ Alternative: **`git worktree`**  
‚Üí Damit kannst du mehrere Branches gleichzeitig bearbeiten  
‚Üí Thema im n√§chsten Video!

### **Was ist `git worktree`?**

üå≤ Mit `git worktree` kannst du **mehrere Arbeitsverzeichnisse gleichzeitig** f√ºr dasselbe Repository erstellen.  
‚Üí Ideal f√ºr parallele Feature-Entwicklung ‚Äì **ohne Stash oder st√§ndiges Branch-Wechseln**.

### **Warum `worktree` statt `stash`?**

‚ùå Bei `git stash`:  
‚Äì √Ñnderungen m√ºssen immer gespeichert & zur√ºckgeholt werden  
‚Äì Auf Dauer un√ºbersichtlich

‚úÖ Bei `git worktree`:  
‚Äì Jeder Branch hat **einen eigenen Ordner**  
‚Äì Saubere Trennung & paralleles Arbeiten

### **Beispiel: Zwei neue Features**

üßÆ Projekt: Taschenrechner  

1. Feature 1: Faktorielle Berechnung
2. Feature 2: BMI-Rechner

‚Üí F√ºr jedes Feature ein eigener Worktree:

```bash
git worktree add ../bmi-feature -b bmi-feature
git worktree add ../faktor-feature -b faktor-feature


### **Entwicklung & Zusammenf√ºhren**

üöß In jedem Worktree:  
‚Äì Neue Dateien & Funktionen entwickeln  
‚Äì `git commit` wie gewohnt  
‚Äì Nach Fertigstellung:  
  ‚Üí `git merge` ins Haupt-Repository  
  ‚Üí `git worktree remove` + Branch l√∂schen

---

### **Vorteile von `git worktree`**

‚úÖ Unabh√§ngige Entwicklungsumgebungen  
‚úÖ Kein versehentliches √úberschreiben  
‚úÖ Klar strukturierte Arbeitsweise  
‚úÖ Ideal f√ºr mehrere Aufgaben gleichzeitig


### **Fazit ‚Äì Git Worktree**

Mit `git worktree` kannst du mehrere Features gleichzeitig entwickeln, ohne die √úbersicht zu verlieren.  
‚Üí Besser als `stash` f√ºr mittlere und gro√üe Projekte  
‚Üí Einfaches Zusammenf√ºhren am Ende mit `merge`


### **Was ist ein Merge-Konflikt?**

‚ö†Ô∏è Merge-Konflikte entstehen, wenn **zwei Branches dieselbe Datei und dieselbe Zeile** ver√§ndert haben.  
‚Üí Git kann nicht automatisch entscheiden, welche √Ñnderung bleiben soll.


### **1. Konflikte manuell l√∂sen**

üõ†Ô∏è Git markiert die Konfliktstellen so:

```

### **Entwicklung & Zusammenf√ºhren**

<<<<<<< HEAD
(dein Code)
=======
(Code vom anderen Branch)
>>>>>>> branch-name
```
‚úÖ L√∂sung:  
‚Äì Behalte, was du brauchst  
‚Äì Entferne die Konflikt-Markierungen  
‚Äì Speichern und `git add` ausf√ºhren

---

### **2. Mit `git mergetool` & `vimdiff` l√∂sen**

üìö Nutze `git mergetool`, um visuell zu vergleichen:

‚Äì Links: **lokale √Ñnderungen**  
‚Äì Rechts: **Remote-Branch**  
‚Äì Mitte: **gemeinsame Basis**

‚û°Ô∏è Kombination mit Tasten (`yy`, `p`) m√∂glich  
‚û°Ô∏è Abschlie√üen mit: `:wqa`

---

### **3. Konflikte mit VS Code l√∂sen**

üñ•Ô∏è Alternativ:  
```bash
code .
```

‚Äì VS Code erkennt Konflikte automatisch  
‚Äì W√§hle:  
‚ÄÉ‚úÖ ‚ÄûCurrent Change‚Äú  
‚ÄÉ‚úÖ ‚ÄûIncoming Change‚Äú  
‚ÄÉ‚úÖ oder ‚ÄûBeide √ºbernehmen‚Äú  
‚Äì Speichern, fertig!

## **Merge oder Rebase?**

| Merge                             | Rebase                             |
|----------------------------------|------------------------------------|
| Beibehaltung der Historie        | Aufger√§umte, lineare Historie      |
| Besser r√ºckverfolgbar            | Weniger Commits sichtbar           |
| Konfliktl√∂sung klar dokumentiert | Vorsicht bei Teamarbeit (Force Push n√∂tig) |

üí° **Tipp:**  
‚Üí Bei Teams: Merge bevorzugt  
‚Üí Bei Solo-Projekten: Rebase m√∂glich

### **Problem: Gro√üe Dateien in GitHub**

üì¶ GitHub erlaubt **max. 100‚ÄØMB pro Datei**  
‚Äì Gr√∂√üere Dateien verursachen **Fehler beim Push**  
‚Äì Auch kleinere Dateien k√∂nnen das Repo **unn√∂tig aufbl√§hen**  
‚Üí Lange Ladezeiten & Speicherprobleme

### **L√∂sung: Git LFS (Large File Storage)**

üß† Git LFS speichert gro√üe Dateien **au√üerhalb des normalen Repos**  
‚Äì Im Git-Repo liegt nur ein **Verweis (Pointer)**  
‚Äì Die Datei selbst liegt auf einem separaten **LFS-Server**

### **Git LFS einrichten & verwenden**

üîß Schritte:  

1. Git LFS installieren & initialisieren:  
‚ÄÉ`git lfs install`  
2. Datei zum Tracking hinzuf√ºgen:  
‚ÄÉ`git lfs track "*.zip"`  
3. Commit & Push wie gewohnt  
‚Üí Datei wird an LFS-Server √ºbertragen, nicht direkt in GitHub

üìÅ Nachverfolgt in `.gitattributes`-Datei

### **Projekt klonen mit LFS-Dateien**

üì• Nach dem Klonen eines LFS-Repos:  
‚Äì Nur Verweise werden heruntergeladen  
‚Äì Um Dateien wirklich zu bekommen:  
‚ÄÉ`git lfs pull`

### **Vorteile von Git LFS**

‚úÖ Besseres Speicher-Management  
‚úÖ Schnellere Klon-Vorg√§nge  
‚úÖ Saubere Repos trotz gro√üer Dateien (z.‚ÄØB. Videos, Bin√§rdateien)

---

### **Was kommt als N√§chstes?**

üîê Wenn gro√üe Dateien **versehentlich** direkt gepusht wurden oder sensible Infos (z.‚ÄØB. API-Schl√ºssel) im Verlauf sind, hilft:  
‚Üí `git filter-repo` (im n√§chsten Video)

### **Problem: Sensible Daten & gro√üe Dateien in der Git-Historie**

üö´ Git speichert **jede Version** einer Datei ‚Äì auch gel√∂schte!  
‚Üí API-Schl√ºssel oder gro√üe Dateien bleiben im **Commit-Verlauf** erhalten  
‚Üí Sicherheitsrisiko & Speicherproblem

### **L√∂sung: `git filter-repo`**

üßπ `git filter-repo` schreibt die gesamte Git-Historie neu:  
‚Äì Entfernt gezielte Dateien r√ºckwirkend aus allen Commits  
‚Äì Ersetzt sensible Inhalte (z.‚ÄØB. API-Keys)  
‚Äì Leichtgewichtig & schneller als `git filter-branch`

### **Gro√üe Dateien aus Git entfernen**

üìÅ Beispiel: 500‚ÄØMB-Datei wurde irrt√ºmlich gepusht  
üëâ Schritte:  

1. Datei sichern  
2. `git filter-repo --invert-paths --path dateiname`  
3. Remote-Verbindung neu setzen  
4. `git push --force`  
‚Üí Datei ist aus allen Commits **gel√∂scht**

### **API-Schl√ºssel ersetzen**

üîê Beispiel: Variable `API_KEY="12345"`  
üëâ Ziel: `"12345"` in allen Commits durch `"REDACTED"` ersetzen

üìÑ Vorgehen:  

1. Ersetzdatei (`replace.txt`) anlegen  
2. `git filter-repo --replace-text replace.txt`  
3. Force Push ausf√ºhren  
‚Üí Schl√ºssel ist √ºberall ersetzt

### **Wichtige Hinweise**

‚ö†Ô∏è Nach `filter-repo`:  
‚Äì Remote (`origin`) muss **neu hinzugef√ºgt** werden  
‚Äì Immer `git push --force` notwendig  
‚Äì Alte Klone sind **nicht mehr kompatibel**

### **Fazit**

‚úÖ Mit `git filter-repo` kannst du:  
‚Äì Gro√üe Dateien aus der Historie l√∂schen  
‚Äì Sensible Daten wie API-Schl√ºssel sicher entfernen  
‚Äì Repositories langfristig sauber und sicher halten

### **Was ist ein Git Submodul?**

üîó Ein **Submodul** ist ein externes Git-Repository, das in dein Hauptprojekt eingebunden wird.  
‚Üí Ideal f√ºr **wiederverwendbare Komponenten** (z.‚ÄØB. Bezahlsysteme, Parser, Bibliotheken)

### **Warum Submodule verwenden?**

‚úÖ Vorteile:  
‚Äì Unabh√§ngige Entwicklung & Versionsverwaltung  
‚Äì Einfaches Wiederverwenden in mehreren Projekten  
‚Äì Sicherheitskritische Komponenten separat verwaltbar  
‚Äì Eigenes Team kann Submodul unabh√§ngig betreuen

### **Beispiel: Mathematischer Parser als Submodul**

üì¶ Statt Code direkt zu integrieren:  

```bash
git submodule add https://github.com/beispiel/math-parser libs/math-parser
```

‚Üí Wird **nicht kopiert**, sondern als **eigene Git-Quelle** verlinkt  
‚Üí In VS Code oder im Terminal jederzeit sichtbar & kontrollierbar

### **Submodul updaten & verwalten**

üì• Nach dem Klonen eines Repos mit Submodul:

```bash
git submodule update --init --recursive
```

üîÅ √Ñnderungen im Submodul √ºbernehmen:  
‚Äì Ins Hauptprojekt integrieren: `git commit`  
‚Äì Alte Version nutzen? ‚Üí Einfach zu bestimmtem Commit zur√ºckkehren

### **Submodul wieder entfernen**

üßπ Schritte:

1. Submodul-Verbindung l√∂sen  
2. Dateien aus dem Projekt entfernen  
3. Eintr√§ge aus `.gitmodules` und `.git/config` bereinigen  
‚Üí Submodul ist vollst√§ndig entfernt

‚úÖ Submodule sind perfekt f√ºr:
‚Äì Wiederverwendbare, getrennt verwaltete Projektteile  
‚Äì Gemeinsame Nutzung √ºber mehrere Projekte hinweg  
‚Äì Klare Trennung zwischen Hauptprojekt und Modul

‚ö†Ô∏è Wenn Module **stark miteinander gekoppelt** sind ‚Üí besser `subtree` (n√§chstes Thema)

### **Was ist ein Git Subtree?**

üå≥ **`git subtree`** integriert ein externes Repository **vollst√§ndig in dein Projekt** ‚Äì der Code wird physisch hinzugef√ºgt.  
‚Üí Ideal, wenn der Code eng mit dem Projekt gekoppelt ist (z.‚ÄØB. UI-Komponenten f√ºr mobile Apps)

### **Submodule vs. Subtree**

| Submodule                              | Subtree                              |
|----------------------------------------|---------------------------------------|
| Verlinkt externes Repo (Referenz)      | F√ºgt Code direkt ein (Kopie)          |
| Extra `git clone` n√∂tig                | Sofort nutzbar                        |
| Unabh√§ngige Entwicklung                | Komplett integriert                   |
| Komplexer beim Entfernen / Updaten     | Einfache Verwaltung im Haupt-Repo     |

### **Subtree hinzuf√ºgen ‚Äì Beispiel**

üì¶ Beispiel: Parser-Modul `math-parser` einbinden  

```bash
git subtree add --prefix=libs/math-parser \
  https://github.com/beispiel/math-parser.git master --squash
```

‚Äì `--prefix`: Zielordner im Projekt  
‚Äì `--squash`: Alle Commits als ein einziger zusammengefasst

### **Subtree verwenden & verwalten**

üîÅ **Update eines Subtrees:**  

```bash
git subtree pull --prefix=libs/math-parser \
  https://github.com/beispiel/math-parser.git master --squash
```

üßπ **Entfernen:**  
‚Äì Einfach Ordner l√∂schen  
‚Äì √Ñnderungen committen & pushen ‚Üí Subtree entfernt

### **Vorteile von Git Subtree**

‚úÖ Komplett integrierter Code  
‚úÖ Keine externen Abh√§ngigkeiten beim Klonen  
‚úÖ Einfach zu nutzen f√ºr tightly coupled Module  
‚úÖ Perfekt f√ºr Komponenten, die mit dem Hauptprojekt wachsen sollen

### **Was ist `git bundle`?**

üì¶ Mit **Git Bundle** kannst du ein komplettes Git-Repository (inkl. Branches & Commits) in eine **einzige Datei** verpacken.  
‚Üí Ideal f√ºr **Offline-Backups**, **sichere Archivierung** oder **Weitergabe ohne Internet**.

### **Warum `git bundle` nutzen?**

‚úÖ Vorteile:
‚Äì Kein Remote-Server (z.‚ÄØB. GitHub) n√∂tig  
‚Äì Funktioniert **ohne Internet**  
‚Äì Perfekt f√ºr gro√üe Repos oder sensible Projekte  
‚Äì Einfach zu transportieren (z.‚ÄØB. USB-Stick, Cloud, E-Mail)

### **Repo als Bundle speichern**

üíæ Befehl zum Erstellen:

```bash
git bundle create projekt.bundle --all
```

‚Üí Erstellt eine `.bundle`-Datei mit **allen Branches & Commits**

üìÅ Alternativ: Nur einen Branch speichern:

```bash
git bundle create projekt.bundle master


### **Bundle wiederherstellen**

üì• Neues Projekt aus Bundle klonen:
```bash
git clone projekt.bundle projekt-ordner
```

‚Üí Funktioniert wie ein normales Repository  
‚Üí Commit-Historie & Branch-Struktur bleiben erhalten

### **Einsatzm√∂glichkeiten von `git bundle`**

üåç Typische Szenarien:
‚Äì Projekte **offline weitergeben**  
‚Äì Sicherung auf **externe Medien**  
‚Äì Migration zwischen **gesch√ºtzten Netzwerken**  
‚Äì Archivierung von Repos f√ºr sp√§tere Nutzung

‚úÖ Mit `git bundle` kannst du dein Repository jederzeit **kompakt sichern oder weitergeben** ‚Äì ganz ohne GitHub oder Internet.  
‚Üí Im n√§chsten Schritt: **nur einen einzelnen Commit** weitergeben mit `git patch`.

### **Was ist ein Git Patch?**

üß© Ein **Patch** speichert √Ñnderungen aus einem oder mehreren Commits als **Textdatei** im Diff-Format.  
‚Üí Ideal, um gezielte √Ñnderungen in andere Projekte oder Branches zu √ºbertragen ‚Äì **ohne komplettes Repo**.

### **Patch-Datei erstellen**

üì¶ Einzelnen Commit als Patch speichern:  

```bash
git format-patch -1 <commit-hash>
```

üì¶ Mehrere Commits (z.‚ÄØB. die letzten 3):  

```bash
git format-patch -3
```

üì¶ Commit-Bereich als Patch:  

```bash
git format-patch <start-hash>..<end-hash>
```

‚Üí Ergebnis: `.patch`-Dateien mit den jeweiligen √Ñnderungen

### **Patch anwenden**

üì• √Ñnderungen in ein anderes Projekt √ºbernehmen:

1. Patch-Datei ins Zielprojekt kopieren  
2. Patch **anwenden (ohne Commit)**:  
‚ÄÉ```bash
git apply datei.patch```

3. Patch **mit Commit √ºbernehmen**:  
‚ÄÉ```bash
git am datei.patch```

‚Üí √Ñnderung erscheint dann **im Commit-Verlauf**

---

### **Wann Git Patch verwenden?**

‚úÖ Typische Anwendungsf√§lle:

‚Äì Einzelne Commits projekt√ºbergreifend teilen  
‚Äì √Ñnderungen √ºber E-Mail oder Datei weitergeben  
‚Äì Offline oder ohne Git-Remote arbeiten  
‚Äì Saubere Code-Reviews vorbereiten

üìÑ Mit `git patch` kannst du gezielte √Ñnderungen leicht exportieren und importieren ‚Äì unabh√§ngig vom gesamten Repository.  
‚Üí Im n√§chsten Video: **GitHub Pages ‚Äì eigene Website direkt aus dem Repo hosten**

### **Was ist GitHub Actions?**

ü§ñ **GitHub Actions** ist ein CI/CD-System (Continuous Integration / Continuous Deployment),  
das automatisch Aufgaben nach jedem Push oder Pull Request ausf√ºhrt.

### **Warum GitHub Actions verwenden?**

‚úÖ Vorteile:
‚Äì Automatisches Testen & Linting  
‚Äì Benachrichtigungen bei Fehlern  
‚Äì Builds erstellen, Deployments durchf√ºhren  
‚Äì Aufgaben zu bestimmten Zeiten planen  
‚Üí Spart Zeit und vermeidet manuelle Fehler

### **Beispiel: Super-Linter einrichten**

üß∞ Ziel: Codequalit√§t pr√ºfen

üìÅ Struktur:

```git
.github/
‚îî‚îÄ‚îÄ workflows/
    ‚îî‚îÄ‚îÄ linter.yml
```

üìÑ Inhalt (`linter.yml`):
‚Äì Trigger: `push`, `pull_request`  
‚Äì Schritte:  
‚ÄÉ1. Repository auschecken  
‚ÄÉ2. Super-Linter starten  
‚ÄÉ3. GitHub Token √ºbergeben

### **Was macht der Linter?**

üîç Bei jedem Push pr√ºft Super-Linter:
‚Äì Syntaxfehler  
‚Äì Formatierung  
‚Äì Dokumentation

‚ùå Bei Fehlern ‚Üí Workflow schl√§gt fehl  
‚úÖ Bei korrektem Code ‚Üí Workflow erfolgreich

---

### **Fehler erkennen & beheben**

üë®‚Äçüíª GitHub zeigt:
‚Äì Welche Datei betroffen ist  
‚Äì In welcher Zeile der Fehler steckt  
‚Äì Warum der Fehler aufgetreten ist

üõ†Ô∏è Fehler korrigieren ‚Üí Push erneut ‚Üí Workflow l√§uft erneut durch

üöÄ Mit GitHub Actions kannst du:
‚Äì Testen, Linting, Build & Deployment automatisieren  
‚Äì Projekte stabiler & professioneller machen  
‚Äì Manuelle Arbeit reduzieren

üìò Tipp: Weitere fertige Actions findest du im [GitHub Marketplace](https://github.com/marketplace)

### **Was sind Git Hooks?**

üß† **Git Hooks** sind Skripte, die bei bestimmten Git-Ereignissen automatisch ausgef√ºhrt werden ‚Äì z.‚ÄØB. vor einem Commit, nach einem Push oder bei einem Merge.

### **Warum Git Hooks verwenden?**

‚úÖ Vorteile:
‚Äì Commit-Nachrichten erzwingen  
‚Äì Codequalit√§t vor Push sicherstellen  
‚Äì Tests vor Merge automatisch ausf√ºhren  
‚Äì E-Mail-/Slack-Benachrichtigungen senden

‚Üí Automatisierte **Regelkontrolle im Team**

### **Beispiele f√ºr wichtige Hooks**

| Hook             | Zweck                               |
|------------------|--------------------------------------|
| `pre-commit`     | Tests ausf√ºhren, Linting pr√ºfen       |
| `commit-msg`     | Commit-Message-Format erzwingen       |
| `pre-push`       | Codequalit√§t pr√ºfen vor Push          |
| `post-commit`    | Slack-Nachricht oder Log schreiben    |

üìÇ Speicherort: `.git/hooks/`  
üìé Standardm√§√üig `.sample` ‚Üí muss umbenannt & aktiviert werden

### **Commit-Message-Format pr√ºfen**

üõë Nur Commits mit folgendem Format erlauben:

```commit
feat: Neue Funktion
fix: Fehlerbehebung
```

üìú Umsetzung:

1. `commit-msg` Hook aktivieren  
2. Format im Skript pr√ºfen  
3. Ung√ºltige Messages blockieren

---

### **Automatisierung im Team**

üí° Mit Git Hooks kannst du:

‚Äì Entwicklungsstandards durchsetzen  
‚Äì Fehlerquellen minimieren  
‚Äì Manuelle Reviews reduzieren  
‚Äì Einheitlichen Workflow sicherstellen

üîí Git Hooks helfen dir, **Team-Regeln durchzusetzen**, **Fehler fr√ºhzeitig zu erkennen** und **deine Git-Prozesse zu automatisieren**.  
‚Üí Im n√§chsten Video: GitHub API nutzen, um Aktionen direkt per Code auszuf√ºhren.

### **Was ist die GitHub API?**

üîß Mit der **GitHub API** kannst du fast alle Funktionen von GitHub per **Code oder Terminal** automatisieren:  
‚Äì Repos verwalten  
‚Äì Issues & Pull Requests erstellen  
‚Äì Actions steuern  
‚Äì Sicherheit & Benutzer verwalten

---

### **Voraussetzung: Token erstellen**

üîê Zuerst wird ein **Personal Access Token** ben√∂tigt:

1. GitHub ‚Üí *Settings* ‚Üí *Developer settings*  
2. ‚ÄûFine-grained token‚Äú generieren  
3. Rechte (z.‚ÄØB. nur Lesen/Schreiben f√ºr Repos) gezielt vergeben  
4. Token sicher speichern

---

### **API-Befehle ausf√ºhren (z.‚ÄØB. mit `curl`)**

üìå Beispiel: Eigenes Profil abfragen

```bash
curl -H "Authorization: token $TOKEN" https://api.github.com/user
```

üìå Beispiel: Neues Repository erstellen

```bash
curl -X POST -H "Authorization: token $TOKEN" \
  -d '{"name":"mein-repo"}' \
  https://api.github.com/user/repos
```

üìå Beispiel: Neues Issue mit Label

```bash
curl -X POST -H "Authorization: token $TOKEN" \
  -d '{"title":"Bug melden","labels":["bug"]}' \
  https://api.github.com/repos/<user>/<repo>/issues
```

---

### **Was ist mit der API m√∂glich?**

‚úÖ M√∂gliche Aktionen:
‚Äì Repos erstellen, l√∂schen  
‚Äì Issues, PRs, Kommentare verwalten  
‚Äì Dateien hochladen  
‚Äì Actions starten oder √ºberwachen  
‚Äì Profil & Organisationen bearbeiten

üìö Die offizielle GitHub API-Dokumentation hilft mit:
‚Äì Beispielen  
‚Äì Endpunkten  
‚Äì Antwortformaten

üß† Die GitHub API ist ein m√§chtiges Tool f√ºr Automatisierung, Integration und Verwaltung ‚Äì direkt √ºber Code oder Terminal.  
‚Üí Im n√§chsten Video: **GitHub Copilot** als smarter Assistent f√ºr API & Git-Kommandos!

### **Was ist Git eigentlich?**

Git = Ein verteiltes Versionskontrollsystem  
‚Üí GitHub = Nur eine von vielen Plattformen, um Git zu nutzen!

---

### **GitHub**

- Gr√∂√üte Entwickler-Community der Welt  
- Ideal f√ºr Open-Source-Projekte  
- Features:
  - **Actions** (CI/CD)
  - **Copilot** (KI-Unterst√ºtzung)
  - 5‚ÄØGB Speicher pro Repo (kostenlos)
- Wird u.‚ÄØa. f√ºr **Linux**, **React**, **VS Code** genutzt

---

### **GitLab**

- Self-Hosted m√∂glich  
- Sehr stark bei **CI/CD & Automatisierung**  
- 10‚ÄØGB Speicher pro Repo  
- Ideal f√ºr gro√üe Unternehmen  
- Fokus auf **Sicherheit & Kontrolle**

---

### **Bitbucket**

- Optimal f√ºr **kleine Teams & Start-ups**  
- Perfekte Integration mit **Jira & Trello**  
- 2‚ÄØGB Speicher pro Repo (kostenlos)  
- Fokus auf Projektmanagement & Agilit√§t

---

### **Azure DevOps**

- Entwickelt von **Microsoft**  
- Perfekt f√ºr .NET & Microsoft-Technologien  
- Starke Sicherheit & DevOps-Integration  
- 10‚ÄØGB Speicher pro Repo  
- Ideal f√ºr **gro√üe Firmen**

---

### **AWS CodeCommit**

- Nahtloses Zusammenspiel mit AWS-Diensten  
- 1‚ÄØGB Speicher pro Repo  
- F√ºr Projekte im **AWS-√ñkosystem** sehr geeignet  
- Skalierbar & cloudbasiert

---

### **Vergleich ‚Äì Wann was nutzen?**

| Plattform       | Ideal f√ºr                                          |
|----------------|----------------------------------------------------|
| **GitHub**      | Open Source, gro√üe Community, Kollaboration       |
| **GitLab**      | Eigenes Hosting, volle Kontrolle, Sicherheit      |
| **Bitbucket**   | Kleine Teams, Atlassian-Tools                     |
| **Azure DevOps**| Microsoft-Umgebungen, gro√üe Projekte              |
| **AWS**         | Cloud-native Entwicklung im AWS-√ñkosystem         |

---

Alle Plattformen basieren auf **Git**, unterscheiden sich aber in Integration, Speicher und Zielgruppen.  
üîç N√§chste Folge: **Git Workflows** ‚Äì wie du dein Team effizient organisierst.

### **Git Workflows ‚Äì √úbersicht**

Es gibt **nicht nur einen** Weg, Git zu nutzen. Unterschiedliche Teams und Projekte erfordern unterschiedliche **Arbeitsabl√§ufe**.

---

### **1. GitHub Flow**

- F√ºr einfache & h√§ufige Deployments
- Schritte:
  - Branch erstellen
  - Feature entwickeln
  - Pull Request (PR) erstellen
  - Testen
  - Merge in `main`
- ‚úÖ Schnell & schlank  
- ‚ö†Ô∏è Kann bei vielen Branches un√ºbersichtlich werden

---

### **2. Git Flow**

- F√ºr **gr√∂√üere, strukturierte Projekte**
- Branch-Typen:
  - `main` ‚Üí stabile Releases
  - `develop` ‚Üí aktives Development
  - `feature/*` ‚Üí neue Features
  - `release/*` ‚Üí Vorbereitung auf Release
  - `hotfix/*` ‚Üí schnelle Fehlerbehebung
- ‚úÖ Sehr organisiert  
- ‚ö†Ô∏è Etwas komplex

---

### **3. Fork Workflow**

- Ideal f√ºr **Open Source**
- Schritte:
  - Projekt forken
  - Eigene √Ñnderungen lokal umsetzen
  - PR stellen
- ‚úÖ Beitr√§ge von au√üen einfach verwalten

---

### **4. Trunk Based Development**

- Entwicklung direkt auf `main`
- Kleine, h√§ufige Commits
- Ideal mit CI/CD
- ‚úÖ Schnell, modern  
- ‚ö†Ô∏è Erfordert stabile Tests & Pipelines

---

### **5. GitLab Flow**

- Mischung aus GitHub & Git Flow
- Fokus: Umgebung (develop, staging, production)
- ‚úÖ Klarer Deployment-Prozess  
- ‚ö†Ô∏è Weniger geeignet ohne CI/CD

---

### **6. Release Flow (Microsoft Style)**

- `main` bleibt stabil  
- Releases √ºber `release/*`-Branches
- ‚úÖ F√ºr gro√üe Unternehmen & feste Versionierung

---

### **Vergleich & Empfehlung**

| Workflow           | Ideal f√ºr                                 |
|--------------------|--------------------------------------------|
| GitHub Flow        | Kleine Projekte, schnelle PRs              |
| Git Flow           | Strukturierte Teams, mittelgro√üe Projekte  |
| Fork Workflow      | Open Source & Community Contributions      |
| Trunk Based Dev    | Moderne Teams mit CI/CD                    |
| GitLab Flow        | Teams mit klaren Umgebungen                |
| Release Flow       | Gro√üe Firmen, stabile Releases             |

---

W√§hle den Workflow, der zu deinem **Team**, deinem **Projektziel** und deinen **Tools** passt.  
üîú N√§chste Folge: **Projektplanung mit GitHub Projects**.

### **GitHub Projects ‚Äì Planung & Nachverfolgung**

Eine gute Projektplanung ist entscheidend f√ºr den Erfolg.  
GitHub bietet mit **Projects** ein m√§chtiges Tool zur **organisierten Verwaltung von Aufgaben**.

---

### **1. Projekt anlegen**

- Unter dem Reiter **Projects** ‚Üí neues Projekt erstellen
- Vorlagen: **Roadmap**, **Tabelle** oder **Board**  
- Aufgaben (Issues) k√∂nnen:
  - Manuell erstellt
  - Oder aus Repositories importiert werden

---

### **2. Aufgaben verwalten**

- Aufgaben (Issues) enthalten:
  - Verantwortliche Person
  - Typ (Feature, Bug, etc.)
  - Status (To Do, In Progress, Done)
  - Start- & Enddatum
  - Review-Datum

---

### **3. Tabellenansicht**

- Zeigt:  
  - Wer macht was  
  - Deadlines & Fortschritt  
- Hilfreich f√ºr Teams

---

### **4 Kanban Board**

- Aufgabenstatus im √úberblick:
  - **To Do**, **In Progress**, **Done**
  - Eigene Spalten m√∂glich (z.‚ÄØB. ‚ÄûTest‚Äú)
- Drag & Drop  
- Automatisches Verschieben nach Abschluss

---

### **5. Vorteile**

- Aufgabenplanung & Fortschrittskontrolle an einem Ort
- Automatische Synchronisierung mit Repositories
- Ideal f√ºr Teamarbeit & transparente Prozesse
- Bestehende Vorlagen aus Open-Source-Projekten wiederverwendbar

---

Mit **GitHub Projects** wird Projektarbeit:

- **strukturierter**
- **nachvollziehbarer**
- **professioneller**

### **Gelernte Inhalte festigen ‚Äì Git & GitHub effektiv anwenden**

Nach 34 Kapiteln:  
‚úÖ Commit  
‚úÖ Branching  
‚úÖ Merge  
‚úÖ Pull Requests  
‚úÖ Open Source Beitr√§ge  
... hast du alles von Grund auf gelernt!

---

### **Wie bleibt das alles im Kopf?**

> **üëâ Nur durch Praxis!**

- Starte ein Projekt mit **GitHub Projects**
- Erstelle **Branches**, mache **Commits**, l√∂se bewusst **Merge-Konflikte**
- Teste **Undo-Funktionen** (z.‚ÄØB. `reset`, `restore`)
- Wiederhole Vorg√§nge regelm√§√üig!

---

### **Simuliere echte Beitr√§ge**

- Erstelle ein **zweites GitHub-Konto**
- Er√∂ffne **Pull Requests** aus diesem Konto
- √úberpr√ºfe und merge selbst ‚Üí **Open-Source-Szenarien nachstellen**

---

### **Wiederholung macht Meister**

- Wiederhole typische Workflows in **verschiedenen Projekten**
- Lerne durch eigene Fehler
- Git wird mit der Zeit zur **zweiten Natur**

---

### **Zusammenf√ºhrung**

- Git & GitHub sind keine Theorie ‚Äì sie leben durch √úbung
- Mit jeder Zeile Code wirst du sicherer
- Bald kannst du sagen:  
  **‚ÄûIch beherrsche Git & GitHub.‚Äú**
